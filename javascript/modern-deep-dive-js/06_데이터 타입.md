# 데이터 타입

### 숫자 타입

정수, 실수(0,2), 음의 정수(-2) 모두 

### 문자열 타입

```javascript
const string1 = "큰 따옴표 내에선 '작은 따옴표'가 문자열로 인식";
const string2 = '작은 따옴표 내에선 "큰 따옴표"가 문자열로 인식';
```

### 템플릿 리터럴

백틱(`) 사용

- 멀티라인 문자열 (줄바꿈)
  - 일반 문자열: 백슬래시(`\`)로 시작하는 이스케이프 시퀀스 사용
    - cf. 이스케이프 시퀀스: 백슬래시(`\`) 뒤에 한 문자나 숫자 조합이 오는 문자 조합
      - ex. `\n`(다음 행으로 이동) `\t`(수평)
  - 템플릿 리터럴: 백틱 안에서 공백 그대로 허용
- 표현식 삽입
  - 일반 문자열: `+` 문자열 연결 연산자로 여러 문자열 연결
  - 템플릿 리터럴: `${}` -> 문자열로 타입이 강제 변환되어 삽입
  ```javascript
  const name = '현주';
  console.log(`My name is ${name}. age is ${10+17}`)
  ```

### 불리언 타입

true/false

### undfined 타입

자바스크립트 엔진이 변수를 초기화할 때 사용하는 값. (ex. var로 선언한 변수)  
할당이 이뤄질 때까지 빈 상태로 두지 않고 undefined로 초기화  
변수 참조시, undefined가 반환된다면 -> 변수 선언 이후 값을 할당하지 않은, 즉 초기화되지 않은 변수라는 것 파악 가능

### null 타입

변수에 값이 없다는 것을 의도적으로 명시  
함수가 유효한 값 반환할 수 없는 경우에도 명시적으로 null 반환

```javascript
document.querySelector('.myClass') // null
```

### 심벌 타입

ES6에서 추가된 타입  
변경 불가능한 원시 타입  
다른 값과 중복되지 않는 유일무이한 값 -> 이름 충돌 위험없는 객체의 유일한 프로퍼티 키로 만들기 위해 사용

```javascript
const key = Symbol('key')
console.log(typeof key) // Symbol

const obj = {}
obj[key] = 'value'
console.log(obj[key]) // value
```

### 객체 타입

### 데이터 타입의 필요성

> 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해  
> 값을 참조할 때, 한번에 읽어들여야할 **메모리 공간의 크기**를 결정하기 위해  
> 메모리에서 읽어들인 **2진수를 어떻게 해석**할지 결정하기 위해

- 데이터 타입에 의한 메모리 공간의 확보와 참조
  - 메모리에 값 저장하려면 메모리 공간의 크기 알아야 낭비/손실없이 저장 가능
  - 참조: 메모리 공간의 크기 알아야한다. 예를 들면 숫자 타입의 값을 제대로 읽어들이지 못하면 값 훼손
    - 자바스크립트 엔진은 score 변수 참조시, 숫자타입의 값이 할당되어 있기에 숫자로 인식하고 8바이트로 메모리공간의 저장된 값을 읽어들인다.
  ```javascript
  var score = 100; // 숫자 저장위해: 메모리 공간 확보 -> 확보된 메모리에 숫자 값 저장
  ```
- 2진수 해석
  - `0100 0001`: 숫자로 해석시 65, 문자열로 해석시 'A'
  - score 변수에 할당된 값의 타입으로 해석

### 동적 타이핑

자바스크립트는 동적 타입 언어로서, 변수 선언시 타입 선언x (let, const..)  
= 어떤 데이터 타입이라도 값 자유롭게 할당 가능 -> 할당에 의해 타입 결정(타입 추론)  
재할당에 의해 타입 변화

- cf. 정적 타입 언어
  - C, C++, Java..
  - 명시적 타입 선언 (변수 선언시 데이터 타입 선언. 타입 변경 불가)
  - `char c`, `int num`
  - 컴파일 시점에 타입 체크 -> 통과못하면 프로그램 실행 자체를 막는다 -> 런타임에서 발생하는 에러 줄임
